


First, you need to create the 3D model on `Salome` and to make the mesh.
When the mesh is created, with specific names for the volumes and surfaces, export your creation in `.med` (example : `example_mesh.med`).
You also need to partition the mesh to allow the number of processors you want to do the calculations in parallel, running this command :
----
~trophime/feelpp_build/new_Json/applications/mesh/feelpp_mesh_partitioner --ifile "name_of_your_file.med" --part "number_of_processors_you_want_to_use" --nochdir
----

example :
----
~trophime/feelpp_build/new_Json/applications/mesh/feelpp_mesh_partitioner --ifile example_mesh.med --part 4 --nochdir
----

This will create a new file, call `"name_of_your_file"_p"number_of_processor_you_want".json` (example_mesh_p4.json) that you will use in your configure file.

You can use ether the linear or the nonlinear model for your calculation, but for our example, we use the linear model, so we select the `thermoelectric-linear` (respectively `thermoelectric-nonlinear`) model in the Json file (details in the <<code.json>>).

When all the files (detailed below) are created, you can run your calculation with this command :

.to execute your calculation
----
mpirun -np "number_of_processor_you_have_chosen_in_the_partition" ~trophime/feelpp_build/new_Json/research/hifimagnet/applications/ThermoElectricModel/feelpp_hfm_thermoelectric_model_3D_V1T1_N1 --config-file "name_of_your_file.cfg"
----

==== Mat√©rial

.Correspondence between parameters and symbols in JSon files
|===
^|Parameter ^|Symbol

|latexmath:[\alpha]
|alpha

|latexmath:[\sigma_{0}] / latexmath:[\sigma]
|sigma0 / sigma

|k~0~ / k
|k0 / k

|T~0~
|T0

|===

There is a dedicated section in the Json file, named `Materials`, to configure the magnet properties.
The structure of a json file is as follows (conditions are details in <<Condition>>) :

[[code.json]]
[source,json]
.Example.json
....
{
    "Name": "ThermoElectric",
    "ShortName":"TE",
    "Model":"thermoelectric-linear",
    "Materials":
    {
	   "Name_of_the_first_volume":
	    {
	     "name":"material_of_this_volume",
	      "alpha":"_",
	      "T0":"_",
	      "sigma0":"_",
	      "k0":"_",
	      "sigma":"sigma0/(1+alpha*(T-T0)):sigma0:alpha:T:T0",
	      "k":"k0*T/((1+alpha*(T-T0))*T0):k0:T:alpha:T0"
	    },
	  "other_volume":
	   {
	    ...
	   }
  },
    "BoundaryConditions":
    {
	   "first_condition(like potential or temperature)":
	    {
	     "type_of_condition":
	      {
		      "Surface_concerned_by_the_condition":
		        {
		          "expr1":"_",
		          "expr2":"_"
		        },
		      "Surface_concerned_by_the_condition":
		        {
		          "expr1":"_",
		          "expr2":"_"
		        }
	      }
	   },
	    "other_condition":
	     {
	      ...
	     }
    },
    "PostProcess":
      {
	     "Fields":["temperature","potential","current"]
      }
}
....
WARNING: The name of the volumes and surfaces must be the same as defined in `Salome`.
Be carefull of the value of the characteristic of the material, the *units being in mm* (like ine <<test.json>>).

It is also necessary to create a file to configure the calculation, call `.cfg` file (example <<example_file.cfg>>).
It will configure which file you will use in your calculations and which type of calculation you do (here we use the Krylov method with the conditions define in the subparts `electro` and `thermal`).
There are few differences between the linear and the nonlinear calculation.

[source,cfg]
.Example_linear.cfg
....
dim=3
geofile="name_of_the_file_created_by_the_partition.json" (or .msh)
geofile-path=$cfgdir


conductor_volume="name_of_your_volume"

[thermoelectric]
model_json=$cfgdir/"name_of_your_file.json"
weakdir=false

[electro]
pc-type=gamg
#ksp-monitor=true
ksp-rtol="relative_convergence_tolerance"
ksp-atol="absolute_convergence_tolerance"
ksp-maxit="maximum_number_of_iterations"
ksp-use-initial-guess-nonzero=1

[thermal]
pc-type=gamg
#ksp-monitor=true
ksp-rtol="relative_convergence_tolerance"
ksp-atol="absolute_convergence_tolerance"
ksp-use-initial-guess-nonzero=1
....

For the nonlinear model, just add this lines in the section `thermoelectric` :

.nonlinear
....
eps_potential=1.e-4
eps_temperature=1.e-4
resolution=picard
itmax_picard=10
update_intensity=true
marker_intensity="the_surface"
target_intensity="the_intensity" (be careful of the sign)
eps_intensity=1.e-2
verbosity=2
....

==== Condition

There are three type of conditions :

1 *Dirichlet*

[source,json]
.Dirichlet Condition
....
"Dirichlet": //values of the solution known at the limits of the domain
  {
    "Surface":
      {
        "expr1":"Value_of_the_solution"
        "expr2":"Volume_concerned"
      },
    "other_surface":
      {
        "expr1":"Value_of_the_solution"
        "expr2":"Volume_concerned"
      }
  }
....
2 *Neumann*

[source,json]
.Neumann Condition
....
"Neumann":  // value of the derivative of the solution knowns at the limit of the domain
  {
    "Surface":
      {
        "expr":"Value_of_derivatives_of_the_solution"
      },
    "other_surface":
      {
        "expr":"Value_of_derivatives_of_the_solution"
      }
  }
....
3 *Robin*

[source,json]
.Robin Condition
....
"Robin":   // linear relation between the value and the derivative at the limits of the domain
  {
    "Surface":
      {
        "expr1":"Value_of_derivatives_of_the_solution"
        "expr2":"Value_of_the_solution"
      },
    "other_surface":
      {
        "expr1":"Value_of_derivatives_of_the_solution"
        "expr2":"Value_of_the_solution"
      }
  }
....

WARNING: Your have to set a condition for each surfaces you have defined.
For those where there is no conditions, set an homogeneous Neumann condition (`"expr":"0"`)
